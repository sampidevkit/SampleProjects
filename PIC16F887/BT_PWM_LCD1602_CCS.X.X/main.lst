CCS PCM C Compiler, Version 5.091, 43599               20-Jun-21 23:37

               Filename:   F:\Github\SAMPIDevKit\SampleProjects\PIC16F887\BT_PWM_LCD1602_CCS.X.X\main.lst

               ROM used:   1685 words (21%)
                           Largest free fragment is 2048
               RAM used:   32 (9%) at main() level
                           63 (17%) worst case
               Stack used: 8 locations (7 in main + 1 for interrupts)
               Stack size: 8

0000:  MOVLW  05
0001:  MOVWF  0A
0002:  GOTO   51F
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.1
002A:  GOTO   02D
002B:  BTFSC  0C.1
002C:  GOTO   04E
002D:  MOVF   22,W
002E:  MOVWF  04
002F:  MOVF   23,W
0030:  MOVWF  77
0031:  MOVF   24,W
0032:  MOVWF  78
0033:  MOVF   25,W
0034:  MOVWF  79
0035:  MOVF   26,W
0036:  MOVWF  7A
0037:  MOVF   27,W
0038:  BSF    03.6
0039:  MOVWF  0D
003A:  BCF    03.6
003B:  MOVF   28,W
003C:  BSF    03.6
003D:  MOVWF  0F
003E:  BCF    03.6
003F:  MOVF   29,W
0040:  BSF    03.6
0041:  MOVWF  0C
0042:  BCF    03.6
0043:  MOVF   2A,W
0044:  BSF    03.6
0045:  MOVWF  0E
0046:  BCF    03.6
0047:  MOVF   20,W
0048:  MOVWF  0A
0049:  SWAPF  21,W
004A:  MOVWF  03
004B:  SWAPF  7F,F
004C:  SWAPF  7F,W
004D:  RETFIE
004E:  BCF    0A.3
004F:  BCF    0A.4
0050:  GOTO   051
.................... #include <16F887.h>
.................... //////////// Standard Header file for the PIC16F887 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC16F887
*
0077:  DATA C6,3B
0078:  DATA 64,16
0079:  DATA 20,00
007A:  DATA D2,32
007B:  DATA 76,16
007C:  DATA 20,00
007D:  DATA 53,3A
007E:  DATA 6F,38
007F:  DATA 20,10
0080:  DATA 20,10
0081:  DATA 20,10
0082:  DATA 20,10
0083:  DATA 20,10
0084:  DATA 20,00
0085:  DATA 25,18
0086:  DATA 35,36
0087:  DATA 64,10
0088:  DATA 72,38
0089:  DATA 6D,00
*
01DF:  MOVF   0B,W
01E0:  MOVWF  40
01E1:  BCF    0B.7
01E2:  BSF    03.5
01E3:  BSF    03.6
01E4:  BSF    0C.7
01E5:  BSF    0C.0
01E6:  NOP
01E7:  NOP
01E8:  BCF    03.5
01E9:  BCF    03.6
01EA:  BTFSC  40.7
01EB:  BSF    0B.7
01EC:  BSF    03.6
01ED:  MOVF   0C,W
01EE:  ANDLW  7F
01EF:  BTFSC  03.2
01F0:  GOTO   233
01F1:  BCF    03.6
01F2:  MOVWF  40
01F3:  BSF    03.6
01F4:  MOVF   0D,W
01F5:  BCF    03.6
01F6:  MOVWF  41
01F7:  BSF    03.6
01F8:  MOVF   0F,W
01F9:  BCF    03.6
01FA:  MOVWF  42
01FB:  MOVF   40,W
01FC:  MOVWF  4B
01FD:  CALL   1B3
01FE:  MOVF   41,W
01FF:  BSF    03.6
0200:  MOVWF  0D
0201:  BCF    03.6
0202:  MOVF   42,W
0203:  BSF    03.6
0204:  MOVWF  0F
0205:  BCF    03.6
0206:  MOVF   0B,W
0207:  MOVWF  43
0208:  BCF    0B.7
0209:  BSF    03.5
020A:  BSF    03.6
020B:  BSF    0C.7
020C:  BSF    0C.0
020D:  NOP
020E:  NOP
020F:  BCF    03.5
0210:  BCF    03.6
0211:  BTFSC  43.7
0212:  BSF    0B.7
0213:  BSF    03.6
0214:  RLF    0C,W
0215:  RLF    0E,W
0216:  ANDLW  7F
0217:  BTFSC  03.2
0218:  GOTO   233
0219:  BCF    03.6
021A:  MOVWF  40
021B:  BSF    03.6
021C:  MOVF   0D,W
021D:  BCF    03.6
021E:  MOVWF  41
021F:  BSF    03.6
0220:  MOVF   0F,W
0221:  BCF    03.6
0222:  MOVWF  42
0223:  MOVF   40,W
0224:  MOVWF  4B
0225:  CALL   1B3
0226:  MOVF   41,W
0227:  BSF    03.6
0228:  MOVWF  0D
0229:  BCF    03.6
022A:  MOVF   42,W
022B:  BSF    03.6
022C:  MOVWF  0F
022D:  INCF   0D,F
022E:  BTFSC  03.2
022F:  INCF   0F,F
0230:  BCF    03.6
0231:  GOTO   1DF
0232:  BSF    03.6
0233:  BCF    03.6
0234:  RETURN
*
0259:  BTFSC  03.1
025A:  GOTO   25E
025B:  MOVLW  53
025C:  MOVWF  04
025D:  BCF    03.7
025E:  CLRF   77
025F:  CLRF   78
0260:  CLRF   79
0261:  CLRF   7A
0262:  CLRF   53
0263:  CLRF   54
0264:  CLRF   55
0265:  CLRF   56
0266:  MOVF   52,W
0267:  IORWF  51,W
0268:  IORWF  50,W
0269:  IORWF  4F,W
026A:  BTFSC  03.2
026B:  GOTO   29C
026C:  MOVLW  20
026D:  MOVWF  57
026E:  BCF    03.0
026F:  RLF    4B,F
0270:  RLF    4C,F
0271:  RLF    4D,F
0272:  RLF    4E,F
0273:  RLF    53,F
0274:  RLF    54,F
0275:  RLF    55,F
0276:  RLF    56,F
0277:  MOVF   52,W
0278:  SUBWF  56,W
0279:  BTFSS  03.2
027A:  GOTO   285
027B:  MOVF   51,W
027C:  SUBWF  55,W
027D:  BTFSS  03.2
027E:  GOTO   285
027F:  MOVF   50,W
0280:  SUBWF  54,W
0281:  BTFSS  03.2
0282:  GOTO   285
0283:  MOVF   4F,W
0284:  SUBWF  53,W
0285:  BTFSS  03.0
0286:  GOTO   296
0287:  MOVF   4F,W
0288:  SUBWF  53,F
0289:  MOVF   50,W
028A:  BTFSS  03.0
028B:  INCFSZ 50,W
028C:  SUBWF  54,F
028D:  MOVF   51,W
028E:  BTFSS  03.0
028F:  INCFSZ 51,W
0290:  SUBWF  55,F
0291:  MOVF   52,W
0292:  BTFSS  03.0
0293:  INCFSZ 52,W
0294:  SUBWF  56,F
0295:  BSF    03.0
0296:  RLF    77,F
0297:  RLF    78,F
0298:  RLF    79,F
0299:  RLF    7A,F
029A:  DECFSZ 57,F
029B:  GOTO   26E
029C:  MOVF   53,W
029D:  MOVWF  00
029E:  INCF   04,F
029F:  MOVF   54,W
02A0:  MOVWF  00
02A1:  INCF   04,F
02A2:  MOVF   55,W
02A3:  MOVWF  00
02A4:  INCF   04,F
02A5:  MOVF   56,W
02A6:  MOVWF  00
02A7:  RETURN
02A8:  MOVF   04,W
02A9:  MOVWF  43
02AA:  BTFSS  42.7
02AB:  GOTO   2B9
02AC:  DECF   43,F
02AD:  BSF    43.5
02AE:  COMF   3F,F
02AF:  COMF   40,F
02B0:  COMF   41,F
02B1:  COMF   42,F
02B2:  INCF   3F,F
02B3:  BTFSC  03.2
02B4:  INCF   40,F
02B5:  BTFSC  03.2
02B6:  INCF   41,F
02B7:  BTFSC  03.2
02B8:  INCF   42,F
02B9:  MOVLW  3B
02BA:  MOVWF  4A
02BB:  MOVLW  9A
02BC:  MOVWF  49
02BD:  MOVLW  CA
02BE:  MOVWF  48
02BF:  CLRF   47
02C0:  MOVLW  0A
02C1:  MOVWF  45
02C2:  BSF    03.1
02C3:  MOVLW  3F
02C4:  MOVWF  04
02C5:  BCF    03.7
02C6:  MOVF   42,W
02C7:  MOVWF  4E
02C8:  MOVF   41,W
02C9:  MOVWF  4D
02CA:  MOVF   40,W
02CB:  MOVWF  4C
02CC:  MOVF   3F,W
02CD:  MOVWF  4B
02CE:  MOVF   4A,W
02CF:  MOVWF  52
02D0:  MOVF   49,W
02D1:  MOVWF  51
02D2:  MOVF   48,W
02D3:  MOVWF  50
02D4:  MOVF   47,W
02D5:  MOVWF  4F
02D6:  CALL   259
02D7:  MOVF   78,W
02D8:  MOVF   77,F
02D9:  BTFSS  03.2
02DA:  GOTO   2EE
02DB:  MOVF   45,W
02DC:  XORLW  01
02DD:  BTFSC  03.2
02DE:  GOTO   2EE
02DF:  MOVF   43,W
02E0:  BTFSC  03.2
02E1:  GOTO   2F0
02E2:  ANDLW  0F
02E3:  SUBWF  45,W
02E4:  BTFSC  03.2
02E5:  GOTO   2E8
02E6:  BTFSC  03.0
02E7:  GOTO   30C
02E8:  BTFSC  43.7
02E9:  GOTO   30C
02EA:  BTFSC  43.6
02EB:  GOTO   2F0
02EC:  MOVLW  20
02ED:  GOTO   308
02EE:  MOVLW  20
02EF:  ANDWF  43,F
02F0:  BTFSS  43.5
02F1:  GOTO   2FB
02F2:  BCF    43.5
02F3:  MOVF   77,W
02F4:  MOVWF  43
02F5:  MOVLW  2D
02F6:  MOVWF  4B
02F7:  CALL   1B3
02F8:  MOVF   43,W
02F9:  MOVWF  77
02FA:  CLRF   43
02FB:  MOVLW  30
02FC:  BTFSS  43.5
02FD:  GOTO   308
02FE:  BCF    43.5
02FF:  MOVF   77,W
0300:  MOVWF  43
0301:  MOVLW  2D
0302:  MOVWF  4B
0303:  CALL   1B3
0304:  MOVF   43,W
0305:  MOVWF  77
0306:  CLRF   43
0307:  MOVLW  30
0308:  ADDWF  77,F
0309:  MOVF   77,W
030A:  MOVWF  4B
030B:  CALL   1B3
030C:  BCF    03.1
030D:  MOVF   4A,W
030E:  MOVWF  4E
030F:  MOVF   49,W
0310:  MOVWF  4D
0311:  MOVF   48,W
0312:  MOVWF  4C
0313:  MOVF   47,W
0314:  MOVWF  4B
0315:  CLRF   52
0316:  CLRF   51
0317:  CLRF   50
0318:  MOVLW  0A
0319:  MOVWF  4F
031A:  CALL   259
031B:  MOVF   7A,W
031C:  MOVWF  4A
031D:  MOVF   79,W
031E:  MOVWF  49
031F:  MOVF   78,W
0320:  MOVWF  48
0321:  MOVF   77,W
0322:  MOVWF  47
0323:  DECFSZ 45,F
0324:  GOTO   2C2
0325:  RETURN
*
0333:  MOVLW  20
0334:  MOVWF  4B
0335:  CLRF   47
0336:  CLRF   48
0337:  CLRF   49
0338:  CLRF   4A
0339:  MOVF   42,W
033A:  MOVWF  7A
033B:  MOVF   41,W
033C:  MOVWF  79
033D:  MOVF   40,W
033E:  MOVWF  78
033F:  MOVF   3F,W
0340:  MOVWF  77
0341:  BCF    03.0
0342:  BTFSS  77.0
0343:  GOTO   352
0344:  MOVF   43,W
0345:  ADDWF  47,F
0346:  MOVF   44,W
0347:  BTFSC  03.0
0348:  INCFSZ 44,W
0349:  ADDWF  48,F
034A:  MOVF   45,W
034B:  BTFSC  03.0
034C:  INCFSZ 45,W
034D:  ADDWF  49,F
034E:  MOVF   46,W
034F:  BTFSC  03.0
0350:  INCFSZ 46,W
0351:  ADDWF  4A,F
0352:  RRF    4A,F
0353:  RRF    49,F
0354:  RRF    48,F
0355:  RRF    47,F
0356:  RRF    7A,F
0357:  RRF    79,F
0358:  RRF    78,F
0359:  RRF    77,F
035A:  DECFSZ 4B,F
035B:  GOTO   341
*
0373:  BTFSC  03.1
0374:  GOTO   378
0375:  MOVLW  47
0376:  MOVWF  04
0377:  BCF    03.7
0378:  MOVF   42,W
0379:  XORWF  46,W
037A:  ANDLW  80
037B:  MOVWF  4C
037C:  BTFSS  42.7
037D:  GOTO   389
037E:  COMF   3F,F
037F:  COMF   40,F
0380:  COMF   41,F
0381:  COMF   42,F
0382:  INCF   3F,F
0383:  BTFSC  03.2
0384:  INCF   40,F
0385:  BTFSC  03.2
0386:  INCF   41,F
0387:  BTFSC  03.2
0388:  INCF   42,F
0389:  BTFSS  46.7
038A:  GOTO   396
038B:  COMF   43,F
038C:  COMF   44,F
038D:  COMF   45,F
038E:  COMF   46,F
038F:  INCF   43,F
0390:  BTFSC  03.2
0391:  INCF   44,F
0392:  BTFSC  03.2
0393:  INCF   45,F
0394:  BTFSC  03.2
0395:  INCF   46,F
0396:  CLRF   77
0397:  CLRF   78
0398:  CLRF   79
0399:  CLRF   7A
039A:  CLRF   47
039B:  CLRF   48
039C:  CLRF   49
039D:  CLRF   4A
039E:  MOVF   46,W
039F:  IORWF  45,W
03A0:  IORWF  44,W
03A1:  IORWF  43,W
03A2:  BTFSC  03.2
03A3:  GOTO   3D4
03A4:  MOVLW  20
03A5:  MOVWF  4B
03A6:  BCF    03.0
03A7:  RLF    3F,F
03A8:  RLF    40,F
03A9:  RLF    41,F
03AA:  RLF    42,F
03AB:  RLF    47,F
03AC:  RLF    48,F
03AD:  RLF    49,F
03AE:  RLF    4A,F
03AF:  MOVF   46,W
03B0:  SUBWF  4A,W
03B1:  BTFSS  03.2
03B2:  GOTO   3BD
03B3:  MOVF   45,W
03B4:  SUBWF  49,W
03B5:  BTFSS  03.2
03B6:  GOTO   3BD
03B7:  MOVF   44,W
03B8:  SUBWF  48,W
03B9:  BTFSS  03.2
03BA:  GOTO   3BD
03BB:  MOVF   43,W
03BC:  SUBWF  47,W
03BD:  BTFSS  03.0
03BE:  GOTO   3CE
03BF:  MOVF   43,W
03C0:  SUBWF  47,F
03C1:  MOVF   44,W
03C2:  BTFSS  03.0
03C3:  INCFSZ 44,W
03C4:  SUBWF  48,F
03C5:  MOVF   45,W
03C6:  BTFSS  03.0
03C7:  INCFSZ 45,W
03C8:  SUBWF  49,F
03C9:  MOVF   46,W
03CA:  BTFSS  03.0
03CB:  INCFSZ 46,W
03CC:  SUBWF  4A,F
03CD:  BSF    03.0
03CE:  RLF    77,F
03CF:  RLF    78,F
03D0:  RLF    79,F
03D1:  RLF    7A,F
03D2:  DECFSZ 4B,F
03D3:  GOTO   3A6
03D4:  BTFSS  4C.7
03D5:  GOTO   3E1
03D6:  COMF   77,F
03D7:  COMF   78,F
03D8:  COMF   79,F
03D9:  COMF   7A,F
03DA:  INCF   77,F
03DB:  BTFSC  03.2
03DC:  INCF   78,F
03DD:  BTFSC  03.2
03DE:  INCF   79,F
03DF:  BTFSC  03.2
03E0:  INCF   7A,F
03E1:  MOVF   47,W
03E2:  MOVWF  00
03E3:  INCF   04,F
03E4:  MOVF   48,W
03E5:  MOVWF  00
03E6:  INCF   04,F
03E7:  MOVF   49,W
03E8:  MOVWF  00
03E9:  INCF   04,F
03EA:  MOVF   4A,W
03EB:  MOVWF  00
*
042E:  MOVF   0B,W
042F:  MOVWF  40
0430:  BCF    0B.7
0431:  BSF    03.5
0432:  BSF    03.6
0433:  BSF    0C.7
0434:  BSF    0C.0
0435:  NOP
0436:  NOP
0437:  BCF    03.5
0438:  BCF    03.6
0439:  BTFSC  40.7
043A:  BSF    0B.7
043B:  BTFSC  03.0
043C:  GOTO   465
043D:  BSF    03.6
043E:  MOVF   0C,W
043F:  ANDLW  7F
0440:  BCF    03.6
0441:  MOVWF  40
0442:  BSF    03.6
0443:  MOVF   0D,W
0444:  BCF    03.6
0445:  MOVWF  41
0446:  BSF    03.6
0447:  MOVF   0F,W
0448:  BCF    03.6
0449:  MOVWF  42
044A:  MOVF   40,W
044B:  MOVWF  4B
044C:  CALL   1B3
044D:  MOVF   41,W
044E:  BSF    03.6
044F:  MOVWF  0D
0450:  BCF    03.6
0451:  MOVF   42,W
0452:  BSF    03.6
0453:  MOVWF  0F
0454:  BCF    03.6
0455:  MOVF   0B,W
0456:  MOVWF  43
0457:  BCF    0B.7
0458:  BSF    03.5
0459:  BSF    03.6
045A:  BSF    0C.7
045B:  BSF    0C.0
045C:  NOP
045D:  NOP
045E:  BCF    03.5
045F:  BCF    03.6
0460:  BTFSC  43.7
0461:  BSF    0B.7
0462:  DECFSZ 3F,F
0463:  GOTO   465
0464:  GOTO   484
0465:  BSF    03.6
0466:  RLF    0C,W
0467:  RLF    0E,W
0468:  ANDLW  7F
0469:  BCF    03.6
046A:  MOVWF  40
046B:  BSF    03.6
046C:  MOVF   0D,W
046D:  BCF    03.6
046E:  MOVWF  41
046F:  BSF    03.6
0470:  MOVF   0F,W
0471:  BCF    03.6
0472:  MOVWF  42
0473:  MOVF   40,W
0474:  MOVWF  4B
0475:  CALL   1B3
0476:  MOVF   41,W
0477:  BSF    03.6
0478:  MOVWF  0D
0479:  BCF    03.6
047A:  MOVF   42,W
047B:  BSF    03.6
047C:  MOVWF  0F
047D:  INCF   0D,F
047E:  BTFSC  03.2
047F:  INCF   0F,F
0480:  BCF    03.0
0481:  BCF    03.6
0482:  DECFSZ 3F,F
0483:  GOTO   42E
*
0485:  MOVF   40,W
0486:  ANDLW  07
0487:  MOVWF  77
0488:  RRF    40,W
0489:  MOVWF  78
048A:  RRF    78,F
048B:  RRF    78,F
048C:  MOVLW  1F
048D:  ANDWF  78,F
048E:  MOVF   78,W
048F:  ADDWF  42,W
0490:  MOVWF  04
0491:  BCF    03.7
0492:  BTFSC  43.0
0493:  BSF    03.7
0494:  CLRF   78
0495:  INCF   78,F
0496:  INCF   77,F
0497:  GOTO   499
0498:  RLF    78,F
0499:  DECFSZ 77,F
049A:  GOTO   498
049B:  MOVF   41,F
049C:  BTFSC  03.2
049D:  GOTO   4A1
049E:  MOVF   78,W
049F:  IORWF  00,F
04A0:  GOTO   4A4
04A1:  COMF   78,F
04A2:  MOVF   78,W
04A3:  ANDWF  00,F
04A4:  BCF    0A.3
04A5:  BCF    0A.4
04A6:  GOTO   4D6 (RETURN)
04A7:  MOVF   40,W
04A8:  ANDLW  07
04A9:  MOVWF  77
04AA:  RRF    40,W
04AB:  MOVWF  78
04AC:  RRF    78,F
04AD:  RRF    78,F
04AE:  MOVLW  1F
04AF:  ANDWF  78,F
04B0:  MOVF   78,W
04B1:  ADDWF  41,W
04B2:  MOVWF  04
04B3:  BCF    03.7
04B4:  BTFSC  42.0
04B5:  BSF    03.7
04B6:  MOVF   00,W
04B7:  MOVWF  78
04B8:  INCF   77,F
04B9:  GOTO   4BB
04BA:  RRF    78,F
04BB:  DECFSZ 77,F
04BC:  GOTO   4BA
04BD:  MOVLW  01
04BE:  ANDWF  78,F
04BF:  BCF    0A.3
04C0:  BCF    0A.4
04C1:  GOTO   4DB (RETURN)
.................... 
.................... #list
.................... 
.................... 
.................... #device ADC=10
.................... #use delay(crystal=20MHz)
*
008A:  MOVLW  4C
008B:  MOVWF  04
008C:  BCF    03.7
008D:  MOVF   00,W
008E:  BTFSC  03.2
008F:  GOTO   09D
0090:  MOVLW  06
0091:  MOVWF  78
0092:  CLRF   77
0093:  DECFSZ 77,F
0094:  GOTO   093
0095:  DECFSZ 78,F
0096:  GOTO   092
0097:  MOVLW  7B
0098:  MOVWF  77
0099:  DECFSZ 77,F
009A:  GOTO   099
009B:  DECFSZ 00,F
009C:  GOTO   090
009D:  RETURN
.................... 
.................... // encoder resolution
.................... #define ENCODER_RES     32 // pulse/round
.................... // status led
.................... #define STATUS_LED      PIN_D0
.................... // buttons
.................... #define BT_DIR          PIN_D3
.................... #define BT_UP           PIN_D2
.................... #define BT_DOWN         PIN_D1
.................... // lcd
.................... #define LCD_ENABLE_PIN  PIN_B7
.................... #define LCD_RS_PIN      PIN_B5
.................... #define LCD_RW_PIN      PIN_B6
.................... #define LCD_DATA4       PIN_E2
.................... #define LCD_DATA5       PIN_E1
.................... #define LCD_DATA6       PIN_E0
.................... #define LCD_DATA7       PIN_D4
.................... 
.................... #include <lcd.c>
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////                             LCD.C                                     ////
.................... ////                 Driver for common LCD modules                         ////
.................... ////                                                                       ////
.................... ////  lcd_init()   Must be called before any other function.               ////
.................... ////                                                                       ////
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         ////
.................... ////                 \a  Set cursor position to upper left                 ////
.................... ////                 \f  Clear display, set cursor to upper left           ////
.................... ////                 \n  Go to start of second line                        ////
.................... ////                 \b  Move back one position                            ////
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     ////
.................... ////              will erase all remanining characters on the current      ////
.................... ////              line, and move the cursor to the beginning of the next   ////
.................... ////              line.                                                    ////
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     ////
.................... ////              will move the cursor to the start of the current         ////
.................... ////              line.                                                    ////
.................... ////                                                                       ////
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        ////
.................... ////                                                                       ////
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             ////
.................... ////                                                                       ////
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         ////
.................... ////              (on=FALSE).                                              ////
.................... ////                                                                       ////
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   ////
.................... ////                                                                       ////
.................... ////                                                                       ////
.................... ////  CONFIGURATION                                                        ////
.................... ////  The LCD can be configured in one of two ways: a.) port access or     ////
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     ////
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     ////
.................... ////  connected to sequential pins on the GPIO.  Pin access                ////
.................... ////  has no requirements, all 7 bits of the control interface can         ////
.................... ////  can be connected to any GPIO using several ports.                    ////
.................... ////                                                                       ////
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     ////
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    ////
.................... ////  of this file to configure the pin order.  If you are using a         ////
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  ////
.................... ////  be defined.                                                          ////
.................... ////                                                                       ////
.................... ////  Example of port access:                                              ////
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         ////
.................... ////                                                                       ////
.................... ////  To use pin access, the following pins must be defined:               ////
.................... ////     LCD_ENABLE_PIN                                                    ////
.................... ////     LCD_RS_PIN                                                        ////
.................... ////     LCD_RW_PIN                                                        ////
.................... ////     LCD_DATA4                                                         ////
.................... ////     LCD_DATA5                                                         ////
.................... ////     LCD_DATA6                                                         ////
.................... ////     LCD_DATA7                                                         ////
.................... ////                                                                       ////
.................... ////  Example of pin access:                                               ////
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    ////
.................... ////     #define LCD_RS_PIN      PIN_E1                                    ////
.................... ////     #define LCD_RW_PIN      PIN_E2                                    ////
.................... ////     #define LCD_DATA4       PIN_D4                                    ////
.................... ////     #define LCD_DATA5       PIN_D5                                    ////
.................... ////     #define LCD_DATA6       PIN_D6                                    ////
.................... ////     #define LCD_DATA7       PIN_D7                                    ////
.................... ////                                                                       ////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __LCD_C__
.................... #define __LCD_C__
.................... 
.................... // define the pinout.
.................... // only required if port access is being used.
.................... typedef struct  
.................... {                            // This structure is overlayed
....................    int1 enable;           // on to an I/O port to gain
....................    int1 rs;               // access to the LCD pins.
....................    int1 rw;               // The bits are allocated from
....................    int1 unused;           // low order up.  ENABLE will
....................    unsigned int     data : 4;         // be LSB pin of that port.
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT.
....................    unsigned int    reserved: 8;
....................   #endif
.................... } LCD_PIN_MAP;
.................... 
.................... // this is to improve compatability with previous LCD drivers that accepted
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B.
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE))
....................  #define LCD_DATA_PORT getenv("SFR:PORTB")
.................... #endif
.................... 
.................... #if defined(__PCB__)
....................    // these definitions only need to be modified for baseline PICs.
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions.
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0};
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF};
.................... #endif
.................... 
.................... ////////////////////// END CONFIGURATION ///////////////////////////////////
.................... 
.................... #ifndef LCD_ENABLE_PIN
....................    #define lcd_output_enable(x) lcdlat.enable=x
....................    #define lcd_enable_tris()   lcdtris.enable=0
.................... #else
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x)
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN)
.................... #endif
.................... 
.................... #ifndef LCD_RS_PIN
....................    #define lcd_output_rs(x) lcdlat.rs=x
....................    #define lcd_rs_tris()   lcdtris.rs=0
.................... #else
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x)
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN)
.................... #endif
.................... 
.................... #ifndef LCD_RW_PIN
....................    #define lcd_output_rw(x) lcdlat.rw=x
....................    #define lcd_rw_tris()   lcdtris.rw=0
.................... #else
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x)
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN)
.................... #endif
.................... 
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4,
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver
.................... // compatible with any code written for the original library
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7))
....................    #define  LCD_DATA4    LCD_DATA0
....................    #define  LCD_DATA5    LCD_DATA1
....................    #define  LCD_DATA6    LCD_DATA2
....................    #define  LCD_DATA7    LCD_DATA3
.................... #endif
.................... 
.................... #ifndef LCD_DATA4
.................... #ifndef LCD_DATA_PORT
....................    #if defined(__PCB__)
....................       #define LCD_DATA_PORT      0x06     //portb
....................       #define set_tris_lcd(x)   set_tris_b(x)
....................    #else
....................      #if defined(PIN_D0)
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd
....................      #else
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb
....................      #endif
....................    #endif   
.................... #endif
.................... 
.................... #if defined(__PCB__)
....................    LCD_PIN_MAP lcd, lcdlat;
....................    #byte lcd = LCD_DATA_PORT
....................    #byte lcdlat = LCD_DATA_PORT
.................... #elif defined(__PCM__)
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris;
....................    #byte lcd = LCD_DATA_PORT
....................    #byte lcdlat = LCD_DATA_PORT
....................    #byte lcdtris = LCD_DATA_PORT+0x80
.................... #elif defined(__PCH__)
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris;
....................    #byte lcd = LCD_DATA_PORT
....................    #byte lcdlat = LCD_DATA_PORT+9
....................    #byte lcdtris = LCD_DATA_PORT+0x12
.................... #elif defined(__PCD__)
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris;
....................    #word lcd = LCD_DATA_PORT
....................    #word lcdlat = LCD_DATA_PORT+2
....................    #word lcdtris = LCD_DATA_PORT-0x02
.................... #endif
.................... #endif   //LCD_DATA4 not defined
.................... 
.................... #ifndef LCD_TYPE
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines
.................... #endif
.................... 
.................... #ifndef LCD_LINE_TWO
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line
.................... #endif
.................... 
.................... #ifndef LCD_LINE_LENGTH
....................    #define LCD_LINE_LENGTH 20
.................... #endif
.................... 
.................... unsigned int8 lcd_read_nibble(void);
.................... 
.................... unsigned int8 lcd_read_byte(void)
.................... {
....................    unsigned int8 low,high;
.................... 
....................  #if defined(__PCB__)
....................    set_tris_lcd(LCD_INPUT_MAP);
....................  #else
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    output_float(LCD_DATA4);
*
0105:  BSF    09.2
....................    output_float(LCD_DATA5);
0106:  BSF    09.1
....................    output_float(LCD_DATA6);
0107:  BSF    09.0
....................    output_float(LCD_DATA7);
0108:  BSF    08.4
....................   #else
....................    lcdtris.data = 0xF;
....................   #endif
....................  #endif
....................         
....................    lcd_output_rw(1);
0109:  BCF    03.5
010A:  BSF    06.6
010B:  BSF    03.5
010C:  BCF    06.6
....................    delay_cycles(1);
010D:  NOP
....................    lcd_output_enable(1);
010E:  BCF    03.5
010F:  BSF    06.7
0110:  BSF    03.5
0111:  BCF    06.7
....................    delay_cycles(1);
0112:  NOP
....................    high = lcd_read_nibble();
0113:  BCF    03.5
0114:  CALL   0CC
0115:  MOVF   78,W
0116:  MOVWF  53
....................       
....................    lcd_output_enable(0);
0117:  BCF    06.7
0118:  BSF    03.5
0119:  BCF    06.7
....................    delay_cycles(1);
011A:  NOP
....................    lcd_output_enable(1);
011B:  BCF    03.5
011C:  BSF    06.7
011D:  BSF    03.5
011E:  BCF    06.7
....................    delay_us(1);
011F:  GOTO   120
0120:  GOTO   121
0121:  NOP
....................    low = lcd_read_nibble();
0122:  BCF    03.5
0123:  CALL   0CC
0124:  MOVF   78,W
0125:  MOVWF  52
....................       
....................    lcd_output_enable(0);
0126:  BCF    06.7
0127:  BSF    03.5
0128:  BCF    06.7
.................... 
....................  #if defined(__PCB__)
....................    set_tris_lcd(LCD_OUTPUT_MAP);
....................  #else
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    output_drive(LCD_DATA4);
0129:  BCF    09.2
....................    output_drive(LCD_DATA5);
012A:  BCF    09.1
....................    output_drive(LCD_DATA6);
012B:  BCF    09.0
....................    output_drive(LCD_DATA7);
012C:  BCF    08.4
....................   #else
....................    lcdtris.data = 0x0;
....................   #endif
....................  #endif
.................... 
....................    return( (high<<4) | low);
012D:  BCF    03.5
012E:  SWAPF  53,W
012F:  MOVWF  77
0130:  MOVLW  F0
0131:  ANDWF  77,F
0132:  MOVF   77,W
0133:  IORWF  52,W
0134:  MOVWF  78
.................... }
.................... 
.................... unsigned int8 lcd_read_nibble(void)
.................... {
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
*
00CC:  CLRF   54
....................    unsigned int8 n = 0x00;
.................... 
....................    /* Read the data port */
....................    n |= input(LCD_DATA4);
00CD:  BSF    03.5
00CE:  BSF    09.2
00CF:  MOVLW  00
00D0:  BCF    03.5
00D1:  BTFSC  09.2
00D2:  MOVLW  01
00D3:  IORWF  54,F
....................    n |= input(LCD_DATA5) << 1;
00D4:  BSF    03.5
00D5:  BSF    09.1
00D6:  MOVLW  00
00D7:  BCF    03.5
00D8:  BTFSC  09.1
00D9:  MOVLW  01
00DA:  MOVWF  77
00DB:  BCF    03.0
00DC:  RLF    77,F
00DD:  MOVF   77,W
00DE:  IORWF  54,F
....................    n |= input(LCD_DATA6) << 2;
00DF:  BSF    03.5
00E0:  BSF    09.0
00E1:  MOVLW  00
00E2:  BCF    03.5
00E3:  BTFSC  09.0
00E4:  MOVLW  01
00E5:  MOVWF  77
00E6:  RLF    77,F
00E7:  RLF    77,F
00E8:  MOVLW  FC
00E9:  ANDWF  77,F
00EA:  MOVF   77,W
00EB:  IORWF  54,F
....................    n |= input(LCD_DATA7) << 3;
00EC:  BSF    03.5
00ED:  BSF    08.4
00EE:  MOVLW  00
00EF:  BCF    03.5
00F0:  BTFSC  08.4
00F1:  MOVLW  01
00F2:  MOVWF  77
00F3:  RLF    77,F
00F4:  RLF    77,F
00F5:  RLF    77,F
00F6:  MOVLW  F8
00F7:  ANDWF  77,F
00F8:  MOVF   77,W
00F9:  IORWF  54,F
....................    
....................    return(n);
00FA:  MOVF   54,W
00FB:  MOVWF  78
....................   #else
00FC:  RETURN
....................    return(lcd.data);
....................   #endif
.................... }
.................... 
.................... void lcd_send_nibble(unsigned int8 n)
.................... {
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    /* Write to the data port */
....................    output_bit(LCD_DATA4, bit_test(n, 0));
*
009E:  BTFSC  53.0
009F:  GOTO   0A2
00A0:  BCF    09.2
00A1:  GOTO   0A3
00A2:  BSF    09.2
00A3:  BSF    03.5
00A4:  BCF    09.2
....................    output_bit(LCD_DATA5, bit_test(n, 1));
00A5:  BCF    03.5
00A6:  BTFSC  53.1
00A7:  GOTO   0AA
00A8:  BCF    09.1
00A9:  GOTO   0AB
00AA:  BSF    09.1
00AB:  BSF    03.5
00AC:  BCF    09.1
....................    output_bit(LCD_DATA6, bit_test(n, 2));
00AD:  BCF    03.5
00AE:  BTFSC  53.2
00AF:  GOTO   0B2
00B0:  BCF    09.0
00B1:  GOTO   0B3
00B2:  BSF    09.0
00B3:  BSF    03.5
00B4:  BCF    09.0
....................    output_bit(LCD_DATA7, bit_test(n, 3));
00B5:  BCF    03.5
00B6:  BTFSC  53.3
00B7:  GOTO   0BA
00B8:  BCF    08.4
00B9:  GOTO   0BB
00BA:  BSF    08.4
00BB:  BSF    03.5
00BC:  BCF    08.4
....................   #else      
....................    lcdlat.data = n;
....................   #endif
....................       
....................    delay_cycles(1);
00BD:  NOP
....................    lcd_output_enable(1);
00BE:  BCF    03.5
00BF:  BSF    06.7
00C0:  BSF    03.5
00C1:  BCF    06.7
....................    delay_us(2);
00C2:  MOVLW  03
00C3:  MOVWF  77
00C4:  DECFSZ 77,F
00C5:  GOTO   0C4
....................    lcd_output_enable(0);
00C6:  BCF    03.5
00C7:  BCF    06.7
00C8:  BSF    03.5
00C9:  BCF    06.7
00CA:  BCF    03.5
00CB:  RETURN
.................... }
.................... 
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n)
.................... {
....................   #if defined(__PCB__)
....................    set_tris_lcd(LCD_OUTPUT_MAP);
....................   #else
....................    lcd_enable_tris();
*
00FD:  BSF    03.5
00FE:  BCF    06.7
....................    lcd_rs_tris();
00FF:  BCF    06.5
....................    lcd_rw_tris();
0100:  BCF    06.6
....................   #endif
.................... 
....................    lcd_output_rs(0);
0101:  BCF    03.5
0102:  BCF    06.5
0103:  BSF    03.5
0104:  BCF    06.5
....................    while ( bit_test(lcd_read_byte(),7) ) ;
*
0135:  MOVF   78,W
0136:  MOVWF  52
0137:  BTFSS  52.7
0138:  GOTO   13B
0139:  BSF    03.5
013A:  GOTO   105
....................    lcd_output_rs(address);
013B:  MOVF   50,F
013C:  BTFSS  03.2
013D:  GOTO   140
013E:  BCF    06.5
013F:  GOTO   141
0140:  BSF    06.5
0141:  BSF    03.5
0142:  BCF    06.5
....................    delay_cycles(1);
0143:  NOP
....................    lcd_output_rw(0);
0144:  BCF    03.5
0145:  BCF    06.6
0146:  BSF    03.5
0147:  BCF    06.6
....................    delay_cycles(1);
0148:  NOP
....................    lcd_output_enable(0);
0149:  BCF    03.5
014A:  BCF    06.7
014B:  BSF    03.5
014C:  BCF    06.7
....................    lcd_send_nibble(n >> 4);
014D:  BCF    03.5
014E:  SWAPF  51,W
014F:  MOVWF  52
0150:  MOVLW  0F
0151:  ANDWF  52,F
0152:  MOVF   52,W
0153:  MOVWF  53
0154:  CALL   09E
....................    lcd_send_nibble(n & 0xf);
0155:  MOVF   51,W
0156:  ANDLW  0F
0157:  MOVWF  52
0158:  MOVWF  53
0159:  CALL   09E
015A:  RETURN
.................... }
.................... 
.................... #if defined(LCD_EXTENDED_NEWLINE)
.................... unsigned int8 g_LcdX, g_LcdY;
.................... #endif
.................... 
.................... void lcd_init(void) 
.................... {
....................    unsigned int8 i;
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6};
015B:  MOVLW  28
015C:  MOVWF  3C
015D:  MOVLW  0C
015E:  MOVWF  3D
015F:  MOVLW  01
0160:  MOVWF  3E
0161:  MOVLW  06
0162:  MOVWF  3F
....................                              // These bytes need to be sent to the LCD
....................                              // to start it up.
....................    
.................... 
....................    lcd_output_enable(0);
0163:  BCF    06.7
0164:  BSF    03.5
0165:  BCF    06.7
....................    lcd_output_rs(0);
0166:  BCF    03.5
0167:  BCF    06.5
0168:  BSF    03.5
0169:  BCF    06.5
....................    lcd_output_rw(0);
016A:  BCF    03.5
016B:  BCF    06.6
016C:  BSF    03.5
016D:  BCF    06.6
.................... 
....................  #if defined(__PCB__)
....................    set_tris_lcd(LCD_OUTPUT_MAP);
....................  #else
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    output_drive(LCD_DATA4);
016E:  BCF    09.2
....................    output_drive(LCD_DATA5);
016F:  BCF    09.1
....................    output_drive(LCD_DATA6);
0170:  BCF    09.0
....................    output_drive(LCD_DATA7);
0171:  BCF    08.4
....................   #else
....................    lcdtris.data = 0x0;
....................   #endif
....................    lcd_enable_tris();
0172:  BCF    06.7
....................    lcd_rs_tris();
0173:  BCF    06.5
....................    lcd_rw_tris();
0174:  BCF    06.6
....................  #endif
....................     
....................    delay_ms(15);
0175:  MOVLW  0F
0176:  BCF    03.5
0177:  MOVWF  4C
0178:  CALL   08A
....................    for(i=1;i<=3;++i)
0179:  MOVLW  01
017A:  MOVWF  3B
017B:  MOVF   3B,W
017C:  SUBLW  03
017D:  BTFSS  03.0
017E:  GOTO   187
....................    {
....................        lcd_send_nibble(3);
017F:  MOVLW  03
0180:  MOVWF  53
0181:  CALL   09E
....................        delay_ms(5);
0182:  MOVLW  05
0183:  MOVWF  4C
0184:  CALL   08A
0185:  INCF   3B,F
0186:  GOTO   17B
....................    }
....................    
....................    lcd_send_nibble(2);
0187:  MOVLW  02
0188:  MOVWF  53
0189:  CALL   09E
....................    delay_ms(5);
018A:  MOVLW  05
018B:  MOVWF  4C
018C:  CALL   08A
....................    for(i=0;i<=3;++i)
018D:  CLRF   3B
018E:  MOVF   3B,W
018F:  SUBLW  03
0190:  BTFSS  03.0
0191:  GOTO   19E
....................       lcd_send_byte(0,LCD_INIT_STRING[i]);
0192:  MOVLW  3C
0193:  ADDWF  3B,W
0194:  MOVWF  04
0195:  BCF    03.7
0196:  MOVF   00,W
0197:  MOVWF  40
0198:  CLRF   50
0199:  MOVF   40,W
019A:  MOVWF  51
019B:  CALL   0FD
.................... 
....................   #if defined(LCD_EXTENDED_NEWLINE)
019C:  INCF   3B,F
019D:  GOTO   18E
019E:  BCF    0A.3
019F:  BCF    0A.4
01A0:  GOTO   54C (RETURN)
....................    g_LcdX = 0;
....................    g_LcdY = 0;
....................   #endif
.................... }
.................... 
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y)
.................... {
....................    unsigned int8 address;
....................    
....................    if(y!=1)
01A1:  DECFSZ 4D,W
01A2:  GOTO   1A4
01A3:  GOTO   1A7
....................       address=LCD_LINE_TWO;
01A4:  MOVLW  40
01A5:  MOVWF  4E
01A6:  GOTO   1A8
....................    else
....................       address=0;
01A7:  CLRF   4E
....................      
....................    address+=x-1;
01A8:  MOVLW  01
01A9:  SUBWF  4C,W
01AA:  ADDWF  4E,F
....................    lcd_send_byte(0,0x80|address);
01AB:  MOVF   4E,W
01AC:  IORLW  80
01AD:  MOVWF  4F
01AE:  CLRF   50
01AF:  MOVF   4F,W
01B0:  MOVWF  51
01B1:  CALL   0FD
.................... 
....................   #if defined(LCD_EXTENDED_NEWLINE)
01B2:  RETURN
....................    g_LcdX = x - 1;
....................    g_LcdY = y - 1;
....................   #endif
.................... }
.................... 
.................... void lcd_putc(char c)
.................... {
....................    switch (c)
01B3:  MOVF   4B,W
01B4:  XORLW  07
01B5:  BTFSC  03.2
01B6:  GOTO   1C1
01B7:  XORLW  0B
01B8:  BTFSC  03.2
01B9:  GOTO   1C6
01BA:  XORLW  06
01BB:  BTFSC  03.2
01BC:  GOTO   1CE
01BD:  XORLW  02
01BE:  BTFSC  03.2
01BF:  GOTO   1D4
01C0:  GOTO   1D9
....................    {
....................       case '\a'   :  lcd_gotoxy(1,1);     break;
01C1:  MOVLW  01
01C2:  MOVWF  4C
01C3:  MOVWF  4D
01C4:  CALL   1A1
01C5:  GOTO   1DE
.................... 
....................       case '\f'   :  lcd_send_byte(0,1);
01C6:  CLRF   50
01C7:  MOVLW  01
01C8:  MOVWF  51
01C9:  CALL   0FD
....................                      delay_ms(2);
01CA:  MOVLW  02
01CB:  MOVWF  4C
01CC:  CALL   08A
....................                     #if defined(LCD_EXTENDED_NEWLINE)
....................                      g_LcdX = 0;
....................                      g_LcdY = 0;
....................                     #endif
....................                      break;
01CD:  GOTO   1DE
.................... 
....................      #if defined(LCD_EXTENDED_NEWLINE)
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break;
....................       case '\n'   :
....................          while (g_LcdX++ < LCD_LINE_LENGTH)
....................          {
....................             lcd_send_byte(1, ' ');
....................          }
....................          lcd_gotoxy(1, g_LcdY+2);
....................          break;
....................      #else
....................       case '\n'   : lcd_gotoxy(1,2);        break;
01CE:  MOVLW  01
01CF:  MOVWF  4C
01D0:  MOVLW  02
01D1:  MOVWF  4D
01D2:  CALL   1A1
01D3:  GOTO   1DE
....................      #endif
....................      
....................       case '\b'   : lcd_send_byte(0,0x10);  break;
01D4:  CLRF   50
01D5:  MOVLW  10
01D6:  MOVWF  51
01D7:  CALL   0FD
01D8:  GOTO   1DE
....................      
....................      #if defined(LCD_EXTENDED_NEWLINE)
....................       default     : 
....................          if (g_LcdX < LCD_LINE_LENGTH)
....................          {
....................             lcd_send_byte(1, c);
....................             g_LcdX++;
....................          }
....................          break;
....................      #else
....................       default     : lcd_send_byte(1,c);     break;
01D9:  MOVLW  01
01DA:  MOVWF  50
01DB:  MOVF   4B,W
01DC:  MOVWF  51
01DD:  CALL   0FD
....................      #endif
....................    }
01DE:  RETURN
.................... }
....................  
.................... char lcd_getc(unsigned int8 x, unsigned int8 y)
.................... {
....................    char value;
.................... 
....................    lcd_gotoxy(x,y);
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low
....................    lcd_output_rs(1);
....................    value = lcd_read_byte();
....................    lcd_output_rs(0);
....................    
....................    return(value);
.................... }
.................... 
.................... // write a custom character to the ram
.................... // which is 0-7 and specifies which character array we are modifying.
.................... // ptr points to an array of 8 bytes, where each byte is the next row of
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and
.................... //    usually you will want to leave this byte 0x00.
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr)
.................... {
....................    unsigned int i;
.................... 
....................    which <<= 3;
....................    which &= 0x38;
.................... 
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address
.................... 
....................    for(i=0; i<8; i++)
....................    {
....................       lcd_send_byte(1, *ptr++);
....................    }
....................   
....................    #if defined(LCD_EXTENDED_NEWLINE)
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address
....................    #endif
.................... }
.................... 
.................... void lcd_cursor_on(int1 on)
.................... {
....................    if (on)
....................    {
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON
....................    }
....................    else
....................    {
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF
....................    }
.................... }
.................... 
.................... #endif
.................... 
.................... #include <stdint.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                           stdint.h                                ////
.................... ////                                                                   ////
.................... //// Standard integer definitions.                                     ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDINT
.................... 
.................... #define _STDINT
.................... 
.................... //////////// exact width
.................... 
.................... typedef signed int8 int8_t;
.................... typedef unsigned int8 uint8_t;
.................... typedef signed int16 int16_t;
.................... typedef unsigned int16 uint16_t;
.................... typedef signed int32 int32_t;
.................... typedef unsigned int32 uint32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int24_t;
.................... //typedef unsigned int24 uint24_t;
.................... typedef signed int64 int64_t;
.................... typedef unsigned int64 uint64_t;
.................... #endif
.................... 
.................... #define INT8_MAX  (127)
.................... #define INT8_MIN  (-128)
.................... #define UINT8_MAX (255)
.................... 
.................... #define INT16_MAX  (32767)
.................... #define INT16_MIN  (-32768)
.................... #define UINT16_MAX (65535)
.................... 
.................... #define INT32_MAX  (2147483647)
.................... #define INT32_MIN  (-2147483648)
.................... #define UINT32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT24_MAX  (8388607)
.................... //#define INT24_MIN  (-8388608)
.................... //#define UINT24_MAX (16777215)
.................... 
.................... #define INT64_MAX  (9223372036854775807)
.................... #define INT64_MIN  (-9223372036854775808)
.................... #define UINT64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// minimum width
.................... 
.................... typedef signed int8 int_least8_t;
.................... typedef unsigned int8 uint_least8_t;
.................... typedef signed int16 int_least16_t;
.................... typedef unsigned int16 uint_least16_t;
.................... typedef signed int32 int_least32_t;
.................... typedef unsigned int32 uint_least32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int_least24_t;
.................... //typedef unsigned int24 uint_least24_t;
.................... typedef signed int64 int_least64_t;
.................... typedef unsigned int64 uint_least64_t;
.................... #endif
.................... 
.................... #define INT_LEAST8_MAX  (127)
.................... #define INT_LEAST8_MIN  (-128)
.................... #define UINT_LEAST8_MAX (255)
.................... 
.................... #define INT_LEAST16_MAX  (32767)
.................... #define INT_LEAST16_MIN  (-32768)
.................... #define UINT_LEAST16_MAX (65535)
.................... 
.................... #define INT_LEAST32_MAX  (2147483647)
.................... #define INT_LEAST32_MIN  (-2147483648)
.................... #define UINT_LEAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_LEAST24_MAX  (8388607)
.................... //#define INT_LEAST24_MIN  (-8388608)
.................... //#define UINT_LEAST24_MAX (16777215)
.................... 
.................... #define INT_LEAST64_MAX  (9223372036854775807)
.................... #define INT_LEAST64_MIN  (-9223372036854775808)
.................... #define UINT_LEAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// fastest width
.................... 
.................... #if defined(__PCD__)
.................... typedef signed int16 int_fast8_t;
.................... typedef unsigned int16 uint_fast8_t;
.................... #define INT_FAST8_MAX  (32767)
.................... #define INT_FAST8_MIN  (-32768)
.................... #define UINT_FAST8_MAX (65535)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... //typedef signed int24 int_fast24_t;
.................... //typedef unsigned int24 uint_fast24_t;
.................... typedef signed int64 int_fast64_t;
.................... typedef unsigned int64 uint_fast64_t;
.................... #else
.................... typedef signed int8 int_fast8_t;
.................... typedef unsigned int8 uint_fast8_t;
.................... #define INT_FAST8_MAX  (127)
.................... #define INT_FAST8_MIN  (-128)
.................... #define UINT_FAST8_MAX (255)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... #endif
.................... 
.................... typedef signed int32 int_fast32_t;
.................... typedef unsigned int32 uint_fast32_t;
.................... 
.................... #define INT_FAST16_MAX  (32767)
.................... #define INT_FAST16_MIN  (-32768)
.................... #define UINT_FAST16_MAX (65535)
.................... 
.................... #define INT_FAST32_MAX  (2147483647)
.................... #define INT_FAST32_MIN  (-2147483648)
.................... #define UINT_FAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_FAST24_MAX  (8388607)
.................... //#define INT_FAST24_MIN  (-8388608)
.................... //#define UINT_FAST24_MAX (16777215)
.................... 
.................... #define INT_FAST64_MAX  (9223372036854775807)
.................... #define INT_FAST64_MIN  (-9223372036854775808)
.................... #define UINT_FAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... //////////// big enough to hold pointers (OPTIONAL)
.................... 
.................... #if defined(__PCD__)
....................    typedef unsigned int32 uintptr_t;
....................    typedef signed int32 intptr_t;
.................... #else
....................    typedef unsigned int16 uintptr_t;
....................    typedef signed int16 intptr_t;
.................... #endif
.................... 
.................... #define INT8_C(val) ((int8_t)val)
.................... #define UINT8_C(val) ((uint8_t)val)
.................... #define INT16_C(val) ((int16_t)val)
.................... #define UINT16_C(val) ((uint16_t)val)
.................... #define INT32_C(val) ((int32_t)val)
.................... #define UINT32_C(val) ((uint32_t)val)
.................... 
.................... #if defined(__PCD__)
.................... #define INT64_C(val) ((int64_t)val)
.................... #define UINT64_C(val) ((uint64_t)val)
.................... #endif
.................... 
.................... /// TODO:
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX
.................... 
.................... 
.................... /////////// greatest width (OPTIONAL)
.................... 
.................... /// TODO
.................... 
.................... /// intmax_t uintmax_t
.................... 
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX
.................... 
.................... /// INTMAX_C(value) UINTMAX_C(value)
.................... 
.................... 
.................... #endif
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... typedef enum
.................... {
....................     TASK_INIT=0,
....................     TASK_STOP,
....................     TASK_FORWARD,
....................     TASK_REVERSE
.................... } task_t;
.................... 
.................... typedef struct
.................... {
....................     bool State;
....................     uint8_t Count;
.................... } bt_t;
.................... 
.................... #define Button_Init(btCxt, Pin)  do{((bt_t)(btCxt)).State=1; ((bt_t)(btCxt)).Count=0;}while(0)
.................... 
.................... volatile uint32_t PulseCount;
.................... 
.................... #INT_TIMER2
.................... 
.................... void TIMER2_isr(void) // <editor-fold defaultstate="collapsed" desc="Base-timer overflow">
.................... {
....................     PulseCount=get_timer1()+1;
*
0051:  MOVF   0F,W
0052:  MOVWF  7A
0053:  MOVF   0E,W
0054:  MOVWF  77
0055:  MOVF   0F,W
0056:  SUBWF  7A,W
0057:  BTFSS  03.2
0058:  GOTO   051
0059:  MOVF   77,W
005A:  MOVWF  58
005B:  MOVF   7A,W
005C:  MOVWF  59
005D:  MOVLW  01
005E:  ADDWF  58,W
005F:  MOVWF  2B
0060:  MOVF   59,W
0061:  MOVWF  2C
0062:  MOVLW  00
0063:  BTFSC  03.0
0064:  MOVLW  01
0065:  ADDWF  2C,F
0066:  CLRF   2D
0067:  BTFSC  03.0
0068:  INCF   2D,F
0069:  CLRF   2E
....................     output_toggle(STATUS_LED);
006A:  BSF    03.5
006B:  BCF    08.0
006C:  MOVLW  01
006D:  BCF    03.5
006E:  XORWF  08,F
....................     set_timer1(0);
006F:  CLRF   0E
0070:  CLRF   0F
0071:  CLRF   0E
....................     set_timer2(0);
0072:  CLRF   11
0073:  BCF    0C.1
0074:  BCF    0A.3
0075:  BCF    0A.4
0076:  GOTO   02D
.................... } // </editor-fold>
.................... 
.................... bool Button_Is_Pressed(bt_t *pCxt, int16_t Pin) // <editor-fold defaultstate="collapsed" desc="Check state of button">
.................... {
....................     if(pCxt->State!=input(Pin))
*
04C2:  MOVF   3B,W
04C3:  MOVWF  78
04C4:  MOVF   3C,W
04C5:  MOVWF  7A
04C6:  MOVF   78,W
04C7:  MOVWF  04
04C8:  BCF    03.7
04C9:  BTFSC  7A.0
04CA:  BSF    03.7
04CB:  CLRF   3F
04CC:  BTFSC  00.0
04CD:  INCF   3F,F
04CE:  MOVF   3D,W
04CF:  MOVWF  40
04D0:  MOVLW  01
04D1:  MOVWF  41
04D2:  CLRF   43
04D3:  MOVLW  80
04D4:  MOVWF  42
04D5:  GOTO   485
04D6:  MOVF   3D,W
04D7:  MOVWF  40
04D8:  CLRF   42
04D9:  CLRF   41
04DA:  GOTO   4A7
04DB:  MOVLW  00
04DC:  BTFSC  78.0
04DD:  MOVLW  01
04DE:  SUBWF  3F,W
04DF:  BTFSC  03.2
04E0:  GOTO   50C
....................     {
....................         if(pCxt->State==1)
04E1:  MOVF   3B,W
04E2:  MOVWF  78
04E3:  MOVF   3C,W
04E4:  MOVWF  7A
04E5:  MOVF   78,W
04E6:  MOVWF  04
04E7:  BCF    03.7
04E8:  BTFSC  7A.0
04E9:  BSF    03.7
04EA:  MOVLW  00
04EB:  BTFSC  00.0
04EC:  MOVLW  01
04ED:  SUBLW  01
04EE:  BTFSS  03.2
04EF:  GOTO   505
....................         {
....................             if(++pCxt->Count>10) // check 10 operation cycles
04F0:  MOVLW  01
04F1:  ADDWF  3B,W
04F2:  MOVWF  04
04F3:  BCF    03.7
04F4:  BTFSC  3C.0
04F5:  BSF    03.7
04F6:  INCF   00,F
04F7:  MOVF   00,W
04F8:  SUBLW  0A
04F9:  BTFSC  03.0
04FA:  GOTO   504
....................             {
....................                 pCxt->State=0;
04FB:  MOVF   3B,W
04FC:  MOVWF  04
04FD:  BCF    03.7
04FE:  BTFSC  3C.0
04FF:  BSF    03.7
0500:  BCF    00.0
....................                 return 1;
0501:  MOVLW  01
0502:  MOVWF  78
0503:  GOTO   51E
....................             }
....................         }
0504:  GOTO   50B
....................         else
....................             pCxt->State=1;
0505:  MOVF   3B,W
0506:  MOVWF  04
0507:  BCF    03.7
0508:  BTFSC  3C.0
0509:  BSF    03.7
050A:  BSF    00.0
....................     }
050B:  GOTO   51C
....................     else if(pCxt->Count>0)
050C:  MOVLW  01
050D:  ADDWF  3B,W
050E:  MOVWF  04
050F:  BCF    03.7
0510:  BTFSC  3C.0
0511:  BSF    03.7
0512:  MOVF   00,F
0513:  BTFSC  03.2
0514:  GOTO   51C
....................         pCxt->Count=0;
0515:  MOVLW  01
0516:  ADDWF  3B,W
0517:  MOVWF  04
0518:  BCF    03.7
0519:  BTFSC  3C.0
051A:  BSF    03.7
051B:  CLRF   00
.................... 
....................     return 0;
051C:  MOVLW  00
051D:  MOVWF  78
051E:  RETURN
.................... } // </editor-fold>
.................... 
.................... void Display_Dir(task_t dir) // <editor-fold defaultstate="collapsed" desc="Display direction">
.................... {
....................     lcd_gotoxy(1, 1); // goto position x of line y
*
0235:  MOVLW  01
0236:  MOVWF  4C
0237:  MOVWF  4D
0238:  CALL   1A1
.................... 
....................     if(dir==TASK_FORWARD)
0239:  MOVF   3F,W
023A:  SUBLW  02
023B:  BTFSS  03.2
023C:  GOTO   245
....................         printf(lcd_putc, "Fwd, ");
023D:  MOVLW  77
023E:  BSF    03.6
023F:  MOVWF  0D
0240:  MOVLW  00
0241:  MOVWF  0F
0242:  BCF    03.6
0243:  CALL   1DF
0244:  GOTO   258
....................     else if(dir==TASK_REVERSE)
0245:  MOVF   3F,W
0246:  SUBLW  03
0247:  BTFSS  03.2
0248:  GOTO   251
....................         printf(lcd_putc, "Rev, ");
0249:  MOVLW  7A
024A:  BSF    03.6
024B:  MOVWF  0D
024C:  MOVLW  00
024D:  MOVWF  0F
024E:  BCF    03.6
024F:  CALL   1DF
0250:  GOTO   258
....................     else
....................         printf(lcd_putc, "Stop           ");
0251:  MOVLW  7D
0252:  BSF    03.6
0253:  MOVWF  0D
0254:  MOVLW  00
0255:  MOVWF  0F
0256:  BCF    03.6
0257:  CALL   1DF
0258:  RETURN
.................... } // </editor-fold>
.................... 
.................... void Display_Duty(int32_t duty) // <editor-fold defaultstate="collapsed" desc="Display duty">
.................... {
....................     duty*=100;
*
0326:  MOVF   3E,W
0327:  MOVWF  42
0328:  MOVF   3D,W
0329:  MOVWF  41
032A:  MOVF   3C,W
032B:  MOVWF  40
032C:  MOVF   3B,W
032D:  MOVWF  3F
032E:  CLRF   46
032F:  CLRF   45
0330:  CLRF   44
0331:  MOVLW  64
0332:  MOVWF  43
*
035C:  MOVF   7A,W
035D:  MOVWF  3E
035E:  MOVF   79,W
035F:  MOVWF  3D
0360:  MOVF   78,W
0361:  MOVWF  3C
0362:  MOVF   77,W
0363:  MOVWF  3B
....................     duty/=1023;
0364:  BCF    03.1
0365:  MOVF   3E,W
0366:  MOVWF  42
0367:  MOVF   3D,W
0368:  MOVWF  41
0369:  MOVF   3C,W
036A:  MOVWF  40
036B:  MOVF   3B,W
036C:  MOVWF  3F
036D:  CLRF   46
036E:  CLRF   45
036F:  MOVLW  03
0370:  MOVWF  44
0371:  MOVLW  FF
0372:  MOVWF  43
*
03EC:  MOVF   7A,W
03ED:  MOVWF  3E
03EE:  MOVF   79,W
03EF:  MOVWF  3D
03F0:  MOVF   78,W
03F1:  MOVWF  3C
03F2:  MOVF   77,W
03F3:  MOVWF  3B
.................... 
....................     if(duty==0)
03F4:  MOVF   3B,F
03F5:  BTFSS  03.2
03F6:  GOTO   404
03F7:  MOVF   3C,F
03F8:  BTFSS  03.2
03F9:  GOTO   404
03FA:  MOVF   3D,F
03FB:  BTFSS  03.2
03FC:  GOTO   404
03FD:  MOVF   3E,F
03FE:  BTFSS  03.2
03FF:  GOTO   404
....................         Display_Dir(TASK_STOP);
0400:  MOVLW  01
0401:  MOVWF  3F
0402:  CALL   235
0403:  GOTO   414
....................     else
....................     {
....................         lcd_gotoxy(6, 1); // goto position x of line y
0404:  MOVLW  06
0405:  MOVWF  4C
0406:  MOVLW  01
0407:  MOVWF  4D
0408:  CALL   1A1
....................         printf(lcd_putc, "%03ld", duty);
0409:  MOVLW  43
040A:  MOVWF  04
040B:  MOVF   3E,W
040C:  MOVWF  42
040D:  MOVF   3D,W
040E:  MOVWF  41
040F:  MOVF   3C,W
0410:  MOVWF  40
0411:  MOVF   3B,W
0412:  MOVWF  3F
0413:  CALL   2A8
....................     }
0414:  RETURN
.................... } // </editor-fold>
.................... 
.................... void Display_Speed(uint32_t count) // <editor-fold defaultstate="collapsed" desc="Display speed">
.................... {
....................     //    static uint16_t lastSpeed=0;
....................     //    float tmp=count;
....................     //    
....................     //    tmp/=(float) ENCODER_RES;
....................     //    tmp/=13.1f; // 13.1ms
....................     //    tmp*=60000.0f; // 60000
....................     //
....................     //    if(lastSpeed!=(uint16_t) tmp)
....................     //    {
....................     //        lastSpeed=(uint16_t) tmp;
....................     lcd_gotoxy(1, 2); // goto position x of line y
0415:  MOVLW  01
0416:  MOVWF  4C
0417:  MOVLW  02
0418:  MOVWF  4D
0419:  CALL   1A1
....................     printf(lcd_putc, "%05ld rpm", count);
041A:  MOVLW  45
041B:  MOVWF  04
041C:  MOVF   3E,W
041D:  MOVWF  42
041E:  MOVF   3D,W
041F:  MOVWF  41
0420:  MOVF   3C,W
0421:  MOVWF  40
0422:  MOVF   3B,W
0423:  MOVWF  3F
0424:  CALL   2A8
0425:  MOVLW  87
0426:  BSF    03.6
0427:  MOVWF  0D
0428:  MOVLW  00
0429:  MOVWF  0F
042A:  BSF    03.0
042B:  MOVLW  04
042C:  BCF    03.6
042D:  MOVWF  3F
*
0484:  RETURN
....................     //}
.................... } // </editor-fold>
.................... 
.................... void main(void)
*
051F:  MOVF   03,W
0520:  ANDLW  1F
0521:  MOVWF  03
0522:  CLRF   30
0523:  CLRF   2F
0524:  MOVLW  FF
0525:  MOVWF  31
0526:  BSF    03.5
0527:  BSF    03.6
0528:  MOVF   09,W
0529:  ANDLW  C0
052A:  MOVWF  09
052B:  BCF    03.6
052C:  BCF    1F.4
052D:  BCF    1F.5
052E:  MOVLW  00
052F:  BSF    03.6
0530:  MOVWF  08
0531:  BCF    03.5
0532:  CLRF   07
0533:  CLRF   08
0534:  CLRF   09
0535:  BCF    03.7
.................... {
....................     int16_t Duty;
....................     task_t DoNext;
....................     bt_t BtDir, BtUp, BtDown;
.................... 
....................     Duty=1023;
0536:  MOVLW  03
0537:  BCF    03.6
0538:  MOVWF  33
0539:  MOVLW  FF
053A:  MOVWF  32
....................     DoNext=TASK_INIT;
053B:  CLRF   34
....................     set_tris_b(0b00011111);
053C:  MOVLW  1F
053D:  BSF    03.5
053E:  MOVWF  06
....................     set_tris_c(0b11111011);
053F:  MOVLW  FB
0540:  MOVWF  07
0541:  BCF    03.5
0542:  MOVWF  31
....................     set_tris_d(0b00001110);
0543:  MOVLW  0E
0544:  BSF    03.5
0545:  MOVWF  08
....................     set_tris_e(0b1000);
0546:  BCF    09.0
0547:  BCF    09.1
0548:  BCF    09.2
0549:  BSF    09.3
.................... 
....................     // LCD
....................     lcd_init();
054A:  BCF    03.5
054B:  GOTO   15B
....................     // Buttons
....................     Button_Init(BtDir);
054C:  BSF    35.0
054D:  CLRF   36
....................     Button_Init(BtUp);
054E:  BSF    37.0
054F:  CLRF   38
....................     Button_Init(BtDown);
0550:  BSF    39.0
0551:  CLRF   3A
....................     enable_interrupts(GLOBAL);
0552:  MOVLW  C0
0553:  IORWF  0B,F
.................... 
....................     while(TRUE)
....................     {
....................         switch(DoNext)
0554:  MOVF   34,W
0555:  BTFSC  03.2
0556:  GOTO   560
0557:  XORLW  01
0558:  BTFSC  03.2
0559:  GOTO   57C
055A:  XORLW  03
055B:  BTFSC  03.2
055C:  GOTO   5DC
055D:  XORLW  01
055E:  BTFSC  03.2
055F:  GOTO   62C
....................         {
....................             default:
....................             case TASK_INIT:
....................                 set_pwm1_duty(0);
0560:  CLRF   15
....................                 setup_ccp1(CCP_OFF);
0561:  MOVLW  F0
0562:  ANDWF  17,F
....................                 setup_timer_1(T1_DISABLED);
0563:  CLRF   10
....................                 setup_timer_2(T2_DISABLED, 255, 16);
0564:  MOVLW  78
0565:  MOVWF  78
0566:  MOVWF  12
0567:  MOVLW  FF
0568:  BSF    03.5
0569:  MOVWF  12
....................                 disable_interrupts(INT_TIMER2);
056A:  BCF    0C.1
....................                 /* LCD 1602 display map
....................                   ----------------------------
....................                  |[1, 1][1, 1][1, ...][16, 1]|
....................                  |[1, 2][2, 2][2, ...][16, 2]|
....................                   ---------------------------- */
....................                 Display_Duty(0);
056B:  BCF    03.5
056C:  CLRF   3E
056D:  CLRF   3D
056E:  CLRF   3C
056F:  CLRF   3B
0570:  CALL   326
....................                 Display_Speed(0);
0571:  CLRF   3E
0572:  CLRF   3D
0573:  CLRF   3C
0574:  CLRF   3B
0575:  CALL   415
....................                 DoNext=TASK_STOP;
0576:  MOVLW  01
0577:  MOVWF  34
....................                 delay_ms(100);
0578:  MOVLW  64
0579:  MOVWF  4C
057A:  CALL   08A
....................                 break;
057B:  GOTO   636
.................... 
....................             case TASK_STOP:
....................                 if(Button_Is_Pressed(&BtDir, BT_DIR))
057C:  CLRF   3C
057D:  MOVLW  35
057E:  MOVWF  3B
057F:  CLRF   3E
0580:  MOVLW  43
0581:  MOVWF  3D
0582:  CALL   4C2
0583:  MOVF   78,F
0584:  BTFSC  03.2
0585:  GOTO   5DB
....................                 {
....................                     DoNext=TASK_FORWARD;
0586:  MOVLW  02
0587:  MOVWF  34
....................                     setup_timer_1(T1_DISABLED);
0588:  CLRF   10
....................                     setup_timer_2(T2_DISABLED, 255, 16);
0589:  MOVLW  78
058A:  MOVWF  78
058B:  MOVWF  12
058C:  MOVLW  FF
058D:  BSF    03.5
058E:  MOVWF  12
....................                     setup_ccp1(CCP_PWM|CCP_PWM_FULL_BRIDGE);
058F:  BCF    03.5
0590:  BCF    31.2
0591:  MOVF   31,W
0592:  BSF    03.5
0593:  MOVWF  07
0594:  BCF    03.5
0595:  BCF    07.2
0596:  BSF    03.5
0597:  BCF    08.5
0598:  BCF    08.6
0599:  BCF    08.7
059A:  MOVLW  4C
059B:  BCF    03.5
059C:  MOVWF  17
059D:  BSF    03.5
059E:  CLRF   1B
059F:  CLRF   1C
05A0:  MOVLW  01
05A1:  MOVWF  1D
....................                     set_pwm1_duty(Duty);
05A2:  BCF    03.5
05A3:  MOVF   33,W
05A4:  MOVWF  79
05A5:  MOVF   32,W
05A6:  MOVWF  78
05A7:  RRF    79,F
05A8:  RRF    78,F
05A9:  RRF    79,F
05AA:  RRF    78,F
05AB:  RRF    79,F
05AC:  MOVF   78,W
05AD:  MOVWF  15
05AE:  RRF    79,F
05AF:  RRF    79,W
05B0:  ANDLW  30
05B1:  MOVWF  77
05B2:  MOVF   17,W
05B3:  ANDLW  CF
05B4:  IORWF  77,W
05B5:  MOVWF  17
....................                     Display_Dir(TASK_FORWARD);
05B6:  MOVLW  02
05B7:  MOVWF  3F
05B8:  CALL   235
....................                     Display_Duty(Duty);
05B9:  CLRF   3E
05BA:  CLRF   3D
05BB:  MOVF   33,W
05BC:  MOVWF  3C
05BD:  MOVF   32,W
05BE:  MOVWF  3B
05BF:  BTFSS  3C.7
05C0:  GOTO   5C3
05C1:  DECF   3D,F
05C2:  DECF   3E,F
05C3:  CALL   326
....................                     Display_Speed(0);
05C4:  CLRF   3E
05C5:  CLRF   3D
05C6:  CLRF   3C
05C7:  CLRF   3B
05C8:  CALL   415
....................                     // Timer 1 (encoder)
....................                     setup_timer_1(T1_EXTERNAL|T1_DIV_BY_1);
05C9:  MOVLW  07
05CA:  MOVWF  10
....................                     // Timer 2 (819 us overflow, 13.1 ms interrupt)
....................                     setup_timer_2(T2_DIV_BY_16, 255, 16);
05CB:  MOVLW  78
05CC:  MOVWF  78
05CD:  IORLW  06
05CE:  MOVWF  12
05CF:  MOVLW  FF
05D0:  BSF    03.5
05D1:  MOVWF  12
....................                     set_timer1(0);
05D2:  BCF    03.5
05D3:  CLRF   0E
05D4:  CLRF   0F
05D5:  CLRF   0E
....................                     set_timer2(0);
05D6:  CLRF   11
....................                     clear_interrupt(INT_TIMER2);
05D7:  BCF    0C.1
....................                     enable_interrupts(INT_TIMER2);
05D8:  BSF    03.5
05D9:  BSF    0C.1
05DA:  BCF    03.5
....................                 }
....................                 break;
05DB:  GOTO   636
.................... 
....................             case TASK_FORWARD:
....................                 if(Button_Is_Pressed(&BtDir, BT_DIR))
05DC:  CLRF   3C
05DD:  MOVLW  35
05DE:  MOVWF  3B
05DF:  CLRF   3E
05E0:  MOVLW  43
05E1:  MOVWF  3D
05E2:  CALL   4C2
05E3:  MOVF   78,F
05E4:  BTFSC  03.2
05E5:  GOTO   62B
....................                 {
....................                     DoNext=TASK_REVERSE;
05E6:  MOVLW  03
05E7:  MOVWF  34
....................                     setup_timer_1(T1_DISABLED);
05E8:  CLRF   10
....................                     setup_timer_2(T2_DISABLED, 255, 16);
05E9:  MOVLW  78
05EA:  MOVWF  78
05EB:  MOVWF  12
05EC:  MOVLW  FF
05ED:  BSF    03.5
05EE:  MOVWF  12
....................                     setup_ccp1(CCP_PWM|CCP_PWM_FULL_BRIDGE);
05EF:  BCF    03.5
05F0:  BCF    31.2
05F1:  MOVF   31,W
05F2:  BSF    03.5
05F3:  MOVWF  07
05F4:  BCF    03.5
05F5:  BCF    07.2
05F6:  BSF    03.5
05F7:  BCF    08.5
05F8:  BCF    08.6
05F9:  BCF    08.7
05FA:  MOVLW  4C
05FB:  BCF    03.5
05FC:  MOVWF  17
05FD:  BSF    03.5
05FE:  CLRF   1B
05FF:  CLRF   1C
0600:  MOVLW  01
0601:  MOVWF  1D
....................                     set_pwm1_duty(Duty);
0602:  BCF    03.5
0603:  MOVF   33,W
0604:  MOVWF  79
0605:  MOVF   32,W
0606:  MOVWF  78
0607:  RRF    79,F
0608:  RRF    78,F
0609:  RRF    79,F
060A:  RRF    78,F
060B:  RRF    79,F
060C:  MOVF   78,W
060D:  MOVWF  15
060E:  RRF    79,F
060F:  RRF    79,W
0610:  ANDLW  30
0611:  MOVWF  77
0612:  MOVF   17,W
0613:  ANDLW  CF
0614:  IORWF  77,W
0615:  MOVWF  17
....................                     Display_Dir(TASK_REVERSE);
0616:  MOVLW  03
0617:  MOVWF  3F
0618:  CALL   235
....................                     // Timer 1 (encoder)
....................                     setup_timer_1(T1_EXTERNAL|T1_DIV_BY_1);
0619:  MOVLW  07
061A:  MOVWF  10
....................                     // Timer 2 (819 us overflow, 13.1 ms interrupt)
....................                     setup_timer_2(T2_DIV_BY_16, 255, 16);
061B:  MOVLW  78
061C:  MOVWF  78
061D:  IORLW  06
061E:  MOVWF  12
061F:  MOVLW  FF
0620:  BSF    03.5
0621:  MOVWF  12
....................                     set_timer1(0);
0622:  BCF    03.5
0623:  CLRF   0E
0624:  CLRF   0F
0625:  CLRF   0E
....................                     set_timer2(0);
0626:  CLRF   11
....................                     clear_interrupt(INT_TIMER2);
0627:  BCF    0C.1
....................                     enable_interrupts(INT_TIMER2);
0628:  BSF    03.5
0629:  BSF    0C.1
062A:  BCF    03.5
....................                 }
....................                 break;
062B:  GOTO   636
.................... 
....................             case TASK_REVERSE:
....................                 if(Button_Is_Pressed(&BtDir, BT_DIR))
062C:  CLRF   3C
062D:  MOVLW  35
062E:  MOVWF  3B
062F:  CLRF   3E
0630:  MOVLW  43
0631:  MOVWF  3D
0632:  CALL   4C2
0633:  MOVF   78,F
0634:  BTFSS  03.2
....................                     DoNext=TASK_INIT;
0635:  CLRF   34
....................                 break;
....................         }
.................... 
....................         if((DoNext==TASK_FORWARD)||(DoNext==TASK_REVERSE))
0636:  MOVF   34,W
0637:  SUBLW  02
0638:  BTFSC  03.2
0639:  GOTO   63E
063A:  MOVF   34,W
063B:  SUBLW  03
063C:  BTFSS  03.2
063D:  GOTO   693
....................         {
.................... 
....................             Display_Speed(PulseCount);
063E:  MOVF   2E,W
063F:  MOVWF  3E
0640:  MOVF   2D,W
0641:  MOVWF  3D
0642:  MOVF   2C,W
0643:  MOVWF  3C
0644:  MOVF   2B,W
0645:  MOVWF  3B
0646:  CALL   415
.................... 
....................             if(Button_Is_Pressed(&BtUp, BT_UP))
0647:  CLRF   3C
0648:  MOVLW  37
0649:  MOVWF  3B
064A:  CLRF   3E
064B:  MOVLW  42
064C:  MOVWF  3D
064D:  CALL   4C2
064E:  MOVF   78,F
064F:  BTFSC  03.2
0650:  GOTO   66D
....................             {
....................                 if(Duty<1023)
0651:  BTFSC  33.7
0652:  GOTO   65D
0653:  MOVF   33,W
0654:  SUBLW  03
0655:  BTFSS  03.0
0656:  GOTO   66C
0657:  BTFSS  03.2
0658:  GOTO   65D
0659:  MOVF   32,W
065A:  SUBLW  FE
065B:  BTFSS  03.0
065C:  GOTO   66C
....................                 {
....................                     Duty+=7;
065D:  MOVLW  07
065E:  ADDWF  32,F
065F:  BTFSC  03.0
0660:  INCF   33,F
....................                     Display_Duty(Duty);
0661:  CLRF   3E
0662:  CLRF   3D
0663:  MOVF   33,W
0664:  MOVWF  3C
0665:  MOVF   32,W
0666:  MOVWF  3B
0667:  BTFSS  3C.7
0668:  GOTO   66B
0669:  DECF   3D,F
066A:  DECF   3E,F
066B:  CALL   326
....................                 }
....................             }
066C:  GOTO   693
....................             else if(Button_Is_Pressed(&BtDown, BT_DOWN))
066D:  CLRF   3C
066E:  MOVLW  39
066F:  MOVWF  3B
0670:  CLRF   3E
0671:  MOVLW  41
0672:  MOVWF  3D
0673:  CALL   4C2
0674:  MOVF   78,F
0675:  BTFSC  03.2
0676:  GOTO   693
....................             {
....................                 if(Duty>0)
0677:  BTFSC  33.7
0678:  GOTO   692
0679:  MOVF   33,F
067A:  BTFSS  03.2
067B:  GOTO   680
067C:  MOVF   32,W
067D:  SUBLW  00
067E:  BTFSC  03.0
067F:  GOTO   692
....................                 {
....................                     Duty-=7;
0680:  MOVLW  07
0681:  SUBWF  32,F
0682:  MOVLW  00
0683:  BTFSS  03.0
0684:  MOVLW  01
0685:  SUBWF  33,F
....................                     Display_Duty(Duty);
0686:  CLRF   3E
0687:  CLRF   3D
0688:  MOVF   33,W
0689:  MOVWF  3C
068A:  MOVF   32,W
068B:  MOVWF  3B
068C:  BTFSS  3C.7
068D:  GOTO   690
068E:  DECF   3D,F
068F:  DECF   3E,F
0690:  CALL   326
....................                 }
0691:  GOTO   693
....................                 else
....................                     DoNext=TASK_INIT;
0692:  CLRF   34
....................             }
....................         }
0693:  GOTO   554
....................     }
.................... }
0694:  SLEEP

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
